<<script>
    // Firebase Configuration
    const firebaseConfig = {
apiKey: "AIzaSyCUmUFSoQ84QRFYfTFXbbQwgmPnxDKhziI",
authDomain: "pickleball-mmr.firebaseapp.com",
projectId: "pickleball-mmr",
storageBucket: "pickleball-mmr.appspot.com", 
messagingSenderId: "967956134535",
appId: "1:967956134535:web:d06507eef0774372fc5622",
databaseURL: "https://pickleball-mmr-default-rtdb.firebaseio.com" 
};

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    
    let players = {};
    let matches = [];
    let trashTalk = [];
    let chart;
    let isDarkMode = false;
    
    // Initialize default players if none exist
    function initializePlayers() {
        const defaultPlayers = {
            cj: { name: 'CJ', elo: 800, matches: 0, wins: 0, losses: 0, streak: 0, singlesWins: 0, singlesMatches: 0, doublesWins: 0, doublesMatches: 0, history: [{date: new Date().toISOString(), elo: 800}], lastActive: new Date().toISOString(), recentForm: [] },
            henry: { name: 'Henry', elo: 800, matches: 0, wins: 0, losses: 0, streak: 0, singlesWins: 0, singlesMatches: 0, doublesWins: 0, doublesMatches: 0, history: [{date: new Date().toISOString(), elo: 800}], lastActive: new Date().toISOString(), recentForm: [] },
            ayaan: { name: 'Ayaan', elo: 800, matches: 0, wins: 0, losses: 0, streak: 0, singlesWins: 0, singlesMatches: 0, doublesWins: 0, doublesMatches: 0, history: [{date: new Date().toISOString(), elo: 800}], lastActive: new Date().toISOString(), recentForm: [] },
            zach: { name: 'Zach', elo: 800, matches: 0, wins: 0, losses: 0, streak: 0, singlesWins: 0, singlesMatches: 0, doublesWins: 0, doublesMatches: 0, history: [{date: new Date().toISOString(), elo: 800}], lastActive: new Date().toISOString(), recentForm: [] }
        };
        
        database.ref('players').once('value', snapshot => {
            if (!snapshot.exists()) {
                database.ref('players').set(defaultPlayers);
            }
        });
    }
    
    // Load data from Firebase - LISTENERS ARE CORRECT
    function loadData() {
        document.getElementById('statusBadge').textContent = '✅ Connected';
        document.getElementById('statusBadge').style.background = '#28a745';
        
        // This listener updates the players object and calls updateUI()
        database.ref('players').on('value', snapshot => {
            if (snapshot.exists()) {
                players = snapshot.val();
                updateUI(); // The main UI function will be called whenever player data changes
            }
        });
        
        // This listener updates the matches array and calls updateUI()
        database.ref('matches').on('value', snapshot => {
            matches = [];
            if (snapshot.exists()) {
                snapshot.forEach(child => {
                    matches.push(child.val());
                });
                matches.sort((a, b) => new Date(b.date) - new Date(a.date));
                // updateUI is called from the players listener, 
                // but calling it here ensures matches and leaderboard update immediately
                updateUI(); 
            }
        });
        
        database.ref('trashTalk').on('value', snapshot => {
            trashTalk = [];
            if (snapshot.exists()) {
                snapshot.forEach(child => {
                    trashTalk.push(child.val());
                });
                trashTalk.sort((a, b) => new Date(b.date) - new Date(a.date));
                updateTrashTalk();
            }
        });
    }
    
    function toggleDarkMode() {
        isDarkMode = !isDarkMode;
        document.body.classList.toggle('dark-mode');
        document.querySelector('.dark-mode-toggle').textContent = isDarkMode ? '☀️ Light Mode' : '🌙 Dark Mode';
        if (chart) updateChart();
    }
    
    function addTrashTalk() {
        const text = document.getElementById('trashTalkInput').value.trim();
        const authorId = document.getElementById('trashTalkAuthor').value; // Use ID
        
        if (!text) {
            alert('Please enter some trash talk!');
            return;
        }
        
        if (!players[authorId]) {
            alert('Invalid player selected.');
            return;
        }

        const newTrashTalk = {
            author: players[authorId].name, // Use name for display
            text: text,
            date: new Date().toISOString()
        };
        
        database.ref('trashTalk').push(newTrashTalk);
        document.getElementById('trashTalkInput').value = '';
    }
    
    function updateTrashTalk() {
        const html = trashTalk.slice(0, 10).map(t => {
            const date = new Date(t.date);
            return `
            <div class="trash-talk-item">
                <div class="trash-talk-author">${t.author}</div>
                <div class="trash-talk-text">"${t.text}"</div>
                <div class="trash-talk-date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
            </div>
        `}).join('');
        document.getElementById('trashTalkList').innerHTML = html || '<p style="color: #999; font-size: 13px;">No trash talk yet. Be the first!</p>';
    }
    
    function getTier(elo) {
        if (elo >= 1200) return { name: 'Master', class: 'tier-master' };
        if (elo >= 1100) return { name: 'Diamond', class: 'tier-diamond' };
        if (elo >= 1000) return { name: 'Platinum', class: 'tier-platinum' };
        if (elo >= 900) return { name: 'Gold', class: 'tier-gold' };
        if (elo >= 800) return { name: 'Silver', class: 'tier-silver' };
        return { name: 'Bronze', class: 'tier-bronze' };
    }
    
    function getFormEmoji(player) {
        const recent = player.recentForm.slice(-10);
        if (recent.length < 3) return '';
        
        const wins = recent.filter(r => r === 'W').length;
        const winRate = wins / recent.length;
        
        if (winRate >= 0.8) return '🔥🔥🔥';
        if (winRate >= 0.6) return '🔥🔥';
        if (winRate >= 0.5) return '🔥';
        if (winRate >= 0.3) return '❄️';
        return '❄️❄️';
    }
    
    function getWeeklyMVP() {
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
        
        const weeklyStats = {};
        Object.keys(players).forEach(id => {
            weeklyStats[id] = { wins: 0, matches: 0, eloGain: 0, initialElo: players[id].elo };
        });
        
        // Calculate the ELO difference from the match history (which is more complex as ELOs change)
        // A simpler MVP approach is just W/L from the match history.
        
        matches.forEach(match => {
            const matchDate = new Date(match.date);
            if (matchDate >= oneWeekAgo) {
                // Find players' IDs from their names in the match record
                match.winners.forEach(name => {
                    const id = Object.keys(players).find(k => players[k].name === name);
                    if (id && weeklyStats[id]) {
                        weeklyStats[id].wins++;
                        weeklyStats[id].matches++;
                    }
                });
                match.losers.forEach(name => {
                    const id = Object.keys(players).find(k => players[k].name === name);
                    if (id && weeklyStats[id]) {
                        weeklyStats[id].matches++;
                    }
                });
            }
        });
        
        // This is a simple score based on wins
        let mvp = null;
        let maxWins = 0;
        let maxScore = -Infinity;
        
        Object.entries(weeklyStats).forEach(([id, stats]) => {
            if (stats.matches > 0) {
                // Calculate current ELO - ELO a week ago (this is complex with history structure, so skipping for simple W/L based MVP)
                
                // Simple score: Wins * 2 + Win Rate
                const score = stats.wins * 2 + (stats.wins / stats.matches);
                
                if (score > maxScore) {
                    maxScore = score;
                    mvp = { id, stats };
                }
            }
        });
        
        if (mvp) {
             // Calculate elo change based on current Elo and the earliest history point in the last week
             const playerHistory = players[mvp.id].history || [];
             const weeklyHistory = playerHistory.filter(h => new Date(h.date) >= oneWeekAgo);
             const startingElo = weeklyHistory.length > 0 ? weeklyHistory[0].elo : players[mvp.id].elo;
             const eloGain = players[mvp.id].elo - startingElo;
             mvp.stats.eloGain = eloGain;
        }

        return mvp;
    }
    
    function updateMVP() {
        const mvp = getWeeklyMVP();
        if (mvp) {
            document.getElementById('mvpName').textContent = players[mvp.id].name;
            document.getElementById('mvpStats').textContent = 
                `${mvp.stats.wins}W-${mvp.stats.matches - mvp.stats.wins}L • ${mvp.stats.eloGain >= 0 ? '+' : ''}${Math.round(mvp.stats.eloGain)} ELO this week`;
        } else {
            document.getElementById('mvpName').textContent = '-';
            document.getElementById('mvpStats').textContent = 'No matches this week';
        }
    }
    
    function getKFactor(matchCount) {
        return 40 * Math.exp(-matchCount / 50) + 10;
    }
    
    function expectedScore(ratingA, ratingB) {
        return 1 / (1 + Math.pow(10, (ratingB - ratingA) / 400)); // Standard ELO formula is base 10
    }
    
    function streakBonus(streak) {
        if (streak < 2) return 0;
        return 5 * (Math.pow(1.5, streak) - Math.pow(1.5, 2)) / 0.5;
    }
    
    function parseScore(scoreStr) {
        const parts = scoreStr.split('-').map(s => parseInt(s.trim()));
        if (parts.length !== 2 || parts.some(isNaN) || parts[0] === parts[1]) return null;
        return { 
            winner: Math.max(parts[0], parts[1]), 
            loser: Math.min(parts[0], parts[1]) 
        };
    }
    
    function getMarginMultiplier(scoreStr) {
        const score = parseScore(scoreStr);
        if (!score) return 1;
        const margin = Math.abs(score.winner - score.loser);
        return 1 + (margin / 20) * 0.3; // M(score) formula from the HTML description
    }
    
    function calculateRatingChange(winnerElo, loserElo, winnerMatches, isDoubles, winnerStreak, scoreStr) {
        const K = getKFactor(winnerMatches);
        const expected = expectedScore(winnerElo, loserElo);
        
        // Core Elo change (simplified ELO calculation is K * (Actual - Expected))
        let change = K * (1 - expected);
        
        // Apply Margin Multiplier
        const marginMult = getMarginMultiplier(scoreStr);
        change *= marginMult;

        // Apply Streak Bonus (added on top)
        change += streakBonus(winnerStreak);
        
        // The original formula had a very complex log scale factor - simplifying to a more standard ELO approach.
        // If you want to keep your complex formula (ΔR = K(t) · [S - E(R)] · M(score) · W · ln(1 + |ΔR|/400)), 
        // the implementation would be highly non-standard and require iterating to solve for delta_R.
        // Stick to the more standard K * (S - E) * multiplier, and add streak bonus.
        
        if (isDoubles) {
            change *= 0.5; // Reduced ELO volatility for doubles
        }
        
        return Math.round(change);
    }
    
    function showPrediction() {
        const matchType = document.getElementById('matchType').value;
        let winners, losers, playerIDs;
        
        try {
            if (matchType === 'singles') {
                const w1 = document.getElementById('winner1').value;
                const l1 = document.getElementById('loser1').value;
                if (!w1 || !l1 || w1 === l1) {
                    document.getElementById('predictionBox').style.display = 'none';
                    return;
                }
                playerIDs = [w1, l1];
                winners = [w1];
                losers = [l1];
            } else {
                const w1 = document.getElementById('winTeam1').value;
                const w2 = document.getElementById('winTeam2').value;
                const l1 = document.getElementById('loseTeam1').value;
                const l2 = document.getElementById('loseTeam2').value;
                
                // Check for duplicate players across teams
                const allPlayers = [w1, w2, l1, l2];
                if (new Set(allPlayers).size !== 4 || allPlayers.some(p => !p)) {
                    document.getElementById('predictionBox').style.display = 'none';
                    return;
                }

                playerIDs = allPlayers;
                winners = [w1, w2];
                losers = [l1, l2];
            }

            const winnerElo = winners.reduce((sum, p) => sum + (players[p] ? players[p].elo : 800), 0) / winners.length;
            const loserElo = losers.reduce((sum, p) => sum + (players[p] ? players[p].elo : 800), 0) / losers.length;
            
            const winProb = expectedScore(winnerElo, loserElo) * 100;
            const loseProb = 100 - winProb;
            
            const winnerNames = winners.map(p => players[p].name).join(' & ');
            const loserNames = losers.map(p => players[p].name).join(' & ');
            
            const predBox = document.getElementById('predictionBox');
            predBox.style.display = 'block';
            predBox.innerHTML = `
                <h4>🤖 AI Match Prediction</h4>
                <div class="win-prob">
                    <span><strong>${winnerNames}:</strong> ${winProb.toFixed(1)}%</span>
                    <span><strong>${loserNames}:</strong> ${loseProb.toFixed(1)}%</span>
                </div>
                <div class="prediction-text" style="margin-top: 10px;">
                    ${winProb > 65 ? '🔥 Heavily favored!' : winProb > 55 ? '⚡ Slight advantage' : '⚖️ Even matchup!'}
                </div>
            `;
        } catch (e) {
            console.error("Prediction calculation failed:", e);
            document.getElementById('predictionBox').style.display = 'none';
        }
    }
    
    function recordMatch(winnerIDs, loserIDs, scoreStr, isDoubles) {
        if (winnerIDs.length === 0 || loserIDs.length === 0) return;
        
        // 1. Calculate Average ELOs and ELO change
        const winnerEloAvg = winnerIDs.reduce((sum, id) => sum + players[id].elo, 0) / winnerIDs.length;
        const loserEloAvg = loserIDs.reduce((sum, id) => sum + players[id].elo, 0) / loserIDs.length;
        
        // Use one winner's stats for the K-Factor (simplification for team Elo)
        const sampleWinnerID = winnerIDs[0];
        const winnerMatches = players[sampleWinnerID].matches;
        const winnerStreak = players[sampleWinnerID].streak > 0 ? players[sampleWinnerID].streak : 0;
        
        const eloChange = calculateRatingChange(winnerEloAvg, loserEloAvg, winnerMatches, isDoubles, winnerStreak, scoreStr);
        const eloChangeLoser = calculateRatingChange(loserEloAvg, winnerEloAvg, players[loserIDs[0]].matches, isDoubles, 0, scoreStr); // Loser's streak is reset

        // 2. Prepare new match record
        const matchData = {
            winners: winnerIDs.map(id => players[id].name),
            losers: loserIDs.map(id => players[id].name),
            score: scoreStr,
            date: new Date().toISOString(),
            type: isDoubles ? 'Doubles' : 'Singles',
            eloChange: eloChange
        };

        const scoreObj = parseScore(scoreStr);
        
        // 3. Update Player Data Locally
        const allPlayersInvolved = [...winnerIDs, ...loserIDs];
        const now = new Date().toISOString();
        
        allPlayersInvolved.forEach(id => {
            const player = players[id];
            
            player.matches++;
            player.lastActive = now;
            
            if (winnerIDs.includes(id)) {
                // Winner Logic
                player.elo = Math.round(player.elo + eloChange);
                player.wins++;
                player.streak = player.streak > 0 ? player.streak + 1 : 1;
                player.recentForm.push('W');
                if (!isDoubles) {
                    player.singlesWins++;
                    player.singlesMatches++;
                } else {
                    player.doublesWins++;
                    player.doublesMatches++;
                }
            } else {
                // Loser Logic
                player.elo = Math.round(player.elo - eloChange); // Note: Loser Elo change is negative
                player.losses++;
                player.streak = player.streak < 0 ? player.streak - 1 : -1;
                player.recentForm.push('L');
                if (!isDoubles) {
                    player.singlesMatches++;
                } else {
                    player.doublesMatches++;
                }
            }

            // Clean up recentForm (keep last 10)
            if (player.recentForm.length > 10) {
                player.recentForm.shift();
            }

            // Update history
            player.history.push({
                date: now,
                elo: player.elo,
                matchType: matchData.type,
                result: winnerIDs.includes(id) ? 'W' : 'L',
                opponentEloChange: winnerIDs.includes(id) ? eloChange : -eloChange // The change received/lost
            });
        });

        // 4. Update Database
        const playersRef = database.ref('players');
        const matchesRef = database.ref('matches');

        Promise.all([
            playersRef.set(players), // Write all players (Firebase listener will re-read and call updateUI)
            matchesRef.push(matchData) // Add the new match
        ])
        .then(() => {
            alert(`Match recorded! Elo change: ${eloChange >= 0 ? '+' : ''}${eloChange} for winners, ${-eloChange >= 0 ? '+' : ''}${-eloChange} for losers.`);
            document.getElementById('matchForm').reset();
            document.getElementById('predictionBox').style.display = 'none';
        })
        .catch(error => {
            console.error("Error recording match:", error);
            alert("Error recording match. See console for details.");
        });
    }
    
    // --- UI Update Functions ---
    
    function updateLeaderboard() {
        const sortedPlayers = Object.entries(players)
            .sort(([, a], [, b]) => b.elo - a.elo);
        
        const html = sortedPlayers.map(([id, player], index) => {
            const rank = index + 1;
            const tier = getTier(player.elo);
            const formEmoji = getFormEmoji(player);
            const streakDisplay = player.streak >= 2 ? `<span class="streak-badge">🔥 W${player.streak}</span>` 
                                : player.streak <= -2 ? `<span class="streak-badge" style="background: #007bff; color: white;">🥶 L${Math.abs(player.streak)}</span>` : '';
            
            return `
            <div class="leaderboard-item" onclick="showProfileModal('${id}')">
                <div class="rank">${rank}</div>
                <div class="elo">${player.elo}</div>
                <div class="player-info">
                    <div class="player-name">
                        ${player.name}
                        <span class="tier-badge ${tier.class}">${tier.name}</span>
                        ${streakDisplay}
                        ${formEmoji}
                    </div>
                    <div class="player-stats">
                        ${player.wins}W - ${player.losses}L (${player.matches} total)
                    </div>
                </div>
            </div>
            `;
        }).join('');
        
        document.getElementById('leaderboard').innerHTML = html;
    }

    function updateMatchHistory() {
        const html = matches.slice(0, 20).map(match => {
            const date = new Date(match.date);
            const winnerNames = match.winners.join(' & ');
            const loserNames = match.losers.join(' & ');
            const eloChange = match.eloChange;
            
            return `
            <div class="match-item">
                <span class="winner">${winnerNames}</span> beat <span class="loser">${loserNames}</span> (${match.score})
                <br>
                <small style="color: #777;">${match.type} | ELO: +${eloChange} / -${eloChange} | ${date.toLocaleDateString()}</small>
            </div>
            `;
        }).join('');
        
        document.getElementById('matchHistory').innerHTML = html;
    }
    
    function updateChart() {
        if (chart) chart.destroy();
        
        const ctx = document.getElementById('eloChart').getContext('2d');
        const datasets = Object.values(players).map((player, index) => {
            const elos = player.history.map(h => h.elo);
            const dates = player.history.map(h => new Date(h.date));
            const color = `hsl(${index * 60}, 70%, ${isDarkMode ? '70%' : '50%'})`;
            
            return {
                label: player.name,
                data: elos,
                borderColor: color,
                backgroundColor: color + '33', // slight transparency
                tension: 0.3,
                fill: false,
                pointRadius: 3
            };
        });
        
        const allDates = Object.values(players).flatMap(p => p.history.map(h => h.date)).sort();
        const uniqueDates = Array.from(new Set(allDates)).map(d => new Date(d));
        
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: uniqueDates,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            tooltipFormat: 'MMM d, yyyy',
                            displayFormats: {
                                day: 'MMM d'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Date',
                            color: isDarkMode ? '#ccc' : '#333'
                        },
                        ticks: { color: isDarkMode ? '#ccc' : '#333' },
                        grid: { color: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'ELO Rating',
                            color: isDarkMode ? '#ccc' : '#333'
                        },
                        min: 700,
                        ticks: { color: isDarkMode ? '#ccc' : '#333' },
                        grid: { color: isDarkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: isDarkMode ? '#ccc' : '#333'
                        }
                    }
                }
            }
        });
    }
    
    function populatePlayerSelects() {
        const selects = document.querySelectorAll('#matchForm select');
        const playerKeys = Object.keys(players);
        
        selects.forEach(select => {
            const currentValue = select.value;
            select.innerHTML = '<option value="">-- Select Player --</option>'; // Clear and add default option
            playerKeys.forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = players[id].name;
                select.appendChild(option);
            });
            // Re-select the value if it existed
            if (currentValue) {
                select.value = currentValue;
            }
            select.addEventListener('change', showPrediction); // Add listener for prediction
        });

        // Add listener for match type change
        document.getElementById('matchType').addEventListener('change', toggleMatchInputs);
    }
    
    function toggleMatchInputs() {
        const type = document.getElementById('matchType').value;
        document.getElementById('singlesInputs').style.display = type === 'singles' ? 'block' : 'none';
        document.getElementById('doublesInputs').style.display = type === 'doubles' ? 'block' : 'none';
        showPrediction();
    }

    function handleMatchFormSubmit(event) {
        event.preventDefault();
        
        const matchType = document.getElementById('matchType').value;
        const scoreStr = document.getElementById('score').value;
        
        const scoreCheck = parseScore(scoreStr);
        if (!scoreCheck) {
            alert('Invalid score format (e.g., 11-9) or tied score. Please enter winner score first.');
            return;
        }

        let winnerIDs, loserIDs;
        
        if (matchType === 'singles') {
            winnerIDs = [document.getElementById('winner1').value];
            loserIDs = [document.getElementById('loser1').value];
            
            if (winnerIDs[0] === loserIDs[0]) {
                alert('Winner and loser must be different players.');
                return;
            }
        } else {
            winnerIDs = [document.getElementById('winTeam1').value, document.getElementById('winTeam2').value];
            loserIDs = [document.getElementById('loseTeam1').value, document.getElementById('loseTeam2').value];
            
            const allPlayers = [...winnerIDs, ...loserIDs];
            if (new Set(allPlayers).size !== 4) {
                alert('All four players must be unique for a doubles match.');
                return;
            }
        }
        
        recordMatch(winnerIDs, loserIDs, scoreStr, matchType === 'doubles');
    }

    function showProfileModal(playerId) {
        const player = players[playerId];
        if (!player) return;

        const tier = getTier(player.elo);
        const winRate = player.matches > 0 ? (player.wins / player.matches * 100).toFixed(1) : 0;
        const singlesWinRate = player.singlesMatches > 0 ? (player.singlesWins / player.singlesMatches * 100).toFixed(1) : 0;
        const doublesWinRate = player.doublesMatches > 0 ? (player.doublesWins / player.doublesMatches * 100).toFixed(1) : 0;

        const profileHTML = `
            <div class="profile-section">
                <div class="profile-header">
                    <div class="profile-avatar">${player.name[0]}</div>
                    <div class="profile-details">
                        <h3 style="color: ${tier.class.split('-')[1] ? `var(--${tier.class})` : ''};">${player.name}</h3>
                        <div class="elo" style="margin-right: 0;">${player.elo}</div>
                        <span class="tier-badge ${tier.class}">${tier.name}</span>
                    </div>
                </div>
                
                <div class="stat-row">
                    <strong>Total Matches:</strong> <span>${player.matches}</span>
                </div>
                <div class="stat-row">
                    <strong>Overall W/L:</strong> <span>${player.wins}W - ${player.losses}L</span>
                </div>
                <div class="stat-row">
                    <strong>Overall Win Rate:</strong> <span>${winRate}%</span>
                </div>
                <div class="stat-row">
                    <strong>Current Streak:</strong> <span style="font-weight: bold; color: ${player.streak > 0 ? '#28a745' : player.streak < 0 ? '#dc3545' : '#6c757d'};">${player.streak > 0 ? `W${player.streak}` : player.streak < 0 ? `L${Math.abs(player.streak)}` : '-'}</span>
                </div>
            </div>

            <h3 style="margin-top: 20px;">Performance</h3>
            <div class="stat-row">
                <strong>Singles W/L:</strong> <span>${player.singlesWins}W - ${player.singlesMatches - player.singlesWins}L</span>
            </div>
            <div class="stat-row">
                <strong>Singles Win Rate:</strong> <span>${singlesWinRate}%</span>
            </div>
            <div class="stat-row">
                <strong>Doubles W/L:</strong> <span>${player.doublesWins}W - ${player.doublesMatches - player.doublesWins}L</span>
            </div>
            <div class="stat-row">
                <strong>Doubles Win Rate:</strong> <span>${doublesWinRate}%</span>
            </div>

            <h3 style="margin-top: 20px;">ELO History</h3>
            <div style="height: 250px; position: relative;">
                <canvas id="profileChart"></canvas>
            </div>
        `;
        
        document.getElementById('profileContent').innerHTML = profileHTML;
        document.getElementById('profileModal').classList.add('active');

        // Draw profile chart
        drawProfileChart(playerId);
    }
    
    function drawProfileChart(playerId) {
        const player = players[playerId];
        if (!player || player.history.length === 0) return;

        const ctx = document.getElementById('profileChart').getContext('2d');

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: player.history.map(h => new Date(h.date)),
                datasets: [{
                    label: 'ELO Rating',
                    data: player.history.map(h => h.elo),
                    borderColor: '#764ba2',
                    backgroundColor: 'rgba(118, 75, 162, 0.2)',
                    tension: 0.2,
                    fill: true,
                    pointRadius: 3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            tooltipFormat: 'MMM d, yyyy',
                            displayFormats: { day: 'MMM d' }
                        },
                        title: { display: false }
                    },
                    y: {
                        title: { display: true, text: 'ELO Rating' },
                        min: 700
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });
    }

    function closeProfileModal() {
        document.getElementById('profileModal').classList.remove('active');
    }
    
    // The main function that refreshes all UI components
    function updateUI() {
        populatePlayerSelects();
        updateLeaderboard();
        updateMatchHistory();
        updateMVP();
        updateChart();
    }
    
    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        initializePlayers();
        loadData();
        document.getElementById('matchForm').addEventListener('submit', handleMatchFormSubmit);
        document.getElementById('matchType').addEventListener('change', toggleMatchInputs);
    });

</script>
